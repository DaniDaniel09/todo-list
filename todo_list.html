<!doctype html>
<html lang="es" data-bs-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lista de tareas · Bootstrap · Drag & Drop</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <!-- Bootstrap Icons (opcional) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <style>
    /* Ajustes visuales */
    body { background: #f8f9fa; }
    .card { border: none; box-shadow: 0 8px 22px rgba(0,0,0,.06); }
    .list-group-item { border: 0; border-bottom: 1px solid rgba(0,0,0,.06); }
    .list-group-item:last-child { border-bottom: 0; }

    /* Checkbox con estilo */
    .task-checkbox.form-check-input {
      width: 1.25rem; height: 1.25rem; cursor: pointer;
      margin-right: .75rem; border-radius: .35rem;
      accent-color: var(--bs-primary);
    }
    .task-checkbox.form-check-input:focus { box-shadow: 0 0 0 .25rem rgba(13,110,253,.15); }

    /* Texto de tarea */
    .task-text { flex: 1; }
    .task-text.completed { text-decoration: line-through; color: var(--bs-secondary-color); }

    .empty-state { color: var(--bs-secondary-color); }
    .btn-icon { width: 2rem; height: 2rem; display: inline-flex; align-items: center; justify-content: center; }
    .fade-enter { animation: fadeIn .2s ease-out; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

    /* Drag & Drop */
    .drag-handle { cursor: grab; }
    .dragging { opacity: .6; }
    .drop-indicator {
      height: 0; border-top: 2px dashed var(--bs-primary); margin: 0.25rem 0;
    }
    .drag-hover { background: rgba(13,110,253,.06); }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="row justify-content-center">
      <div class="col-12 col-md-10 col-lg-8">
        <div class="card rounded-4">
          <div class="card-body p-4">
            <div class="d-flex align-items-center mb-3">
              <i class="bi bi-check2-square fs-3 text-primary me-2"></i>
              <h1 class="h3 m-0">Lista de tareas</h1>
            </div>

            <!-- Tabs -->
            <ul class="nav nav-tabs" id="todoTabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="pendientes-tab" data-bs-toggle="tab" data-bs-target="#pendientes" type="button" role="tab" aria-controls="pendientes" aria-selected="true">Por completar</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="completadas-tab" data-bs-toggle="tab" data-bs-target="#completadas" type="button" role="tab" aria-controls="completadas" aria-selected="false">Completadas</button>
              </li>
            </ul>

            <div class="tab-content pt-3" id="todoTabsContent">
              <!-- TAB PENDIENTES -->
              <div class="tab-pane fade show active" id="pendientes" role="tabpanel" aria-labelledby="pendientes-tab" tabindex="0">
                <!-- Form añadir -->
                <form id="addForm" class="row g-2 align-items-center mb-3" autocomplete="off">
                  <div class="col-12 col-md">
                    <label for="newTaskInput" class="visually-hidden">Nueva tarea</label>
                    <input id="newTaskInput" class="form-control form-control-lg" type="text" placeholder="Escribe una nueva tarea y pulsa Enter…" maxlength="200" />
                  </div>
                  <div class="col-12 col-md-auto">
                    <button class="btn btn-primary btn-lg w-100" type="submit"><i class="bi bi-plus-lg me-1"></i> Añadir</button>
                  </div>
                </form>

                <div class="d-flex flex-wrap gap-2 mb-3">
                  <input id="txtFileInput" type="file" accept=".txt,.md,text/plain" class="d-none" />
                  <button type="button" id="importTxtBtn" class="btn btn-outline-secondary"><i class="bi bi-file-earmark-arrow-up me-1"></i> Importar TXT</button>
                  <button type="button" id="exportJsonBtn" class="btn btn-outline-secondary"><i class="bi bi-download me-1"></i> Exportar JSON</button>
                  <span class="ms-1 text-body-secondary">Guardado automático en este navegador · arrastra para reordenar</span>
                </div>

                <!-- Lista pendientes -->
                <ul id="pendingList" class="list-group list-group-flush" aria-label="Lista de tareas pendientes"></ul>
                <p id="pendingEmpty" class="empty-state text-center my-3 d-none">No hay tareas pendientes aún.</p>
              </div>

              <!-- TAB COMPLETADAS -->
              <div class="tab-pane fade" id="completadas" role="tabpanel" aria-labelledby="completadas-tab" tabindex="0">
                <ul id="completedList" class="list-group list-group-flush" aria-label="Lista de tareas completadas"></ul>
                <p id="completedEmpty" class="empty-state text-center my-3 d-none">Todavía no hay tareas completadas.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Modal Editar -->
        <div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="editModalLabel">Editar tarea</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
              </div>
              <form id="editForm">
                <div class="modal-body">
                  <div class="mb-3">
                    <label for="editInput" class="form-label">Texto</label>
                    <input type="text" id="editInput" class="form-control" maxlength="200" required />
                    <div class="form-text">Solo puedes editar tareas en "Por completar".</div>
                  </div>
                </div>
                <div class="modal-footer">
                  <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                  <button type="submit" class="btn btn-primary">Guardar</button>
                </div>
              </form>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Bootstrap Bundle (incluye Popper) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

  <script>
  (function() {
    const DB_KEY = 'tareas_db_v3_dragdrop'; // nueva versión para incluir órdenes
    const LEGACY_KEYS = ['tareas_db_v2','tareas-bootstrap-v1'];

    /** @type {{id:string,text:string,completed:boolean,createdAt:number,completedAt?:number,orderPending?:number,orderCompleted?:number}[]} */
    let tasks = [];
    let editModal, editId = null;

    function getSnapshot() { return { version: 3, updatedAt: Date.now(), tasks: tasks }; }

    // Elementos
    const addForm = document.getElementById('addForm');
    const newTaskInput = document.getElementById('newTaskInput');
    const pendingList = document.getElementById('pendingList');
    const completedList = document.getElementById('completedList');
    const pendingEmpty = document.getElementById('pendingEmpty');
    const completedEmpty = document.getElementById('completedEmpty');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const txtFileInput = document.getElementById('txtFileInput');
    const importTxtBtn = document.getElementById('importTxtBtn');

    const editForm = document.getElementById('editForm');
    const editInput = document.getElementById('editInput');
    editModal = new bootstrap.Modal('#editModal');

    // Utilidades
    const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

    function load() {
      try {
        // v3
        const raw = localStorage.getItem(DB_KEY);
        if (raw) {
          const obj = JSON.parse(raw);
          tasks = Array.isArray(obj) ? obj : (obj && Array.isArray(obj.tasks) ? obj.tasks : []);
          if (!Array.isArray(tasks)) tasks = [];
          normalizeOrders();
          return;
        }
        // migraciones
        for (const key of LEGACY_KEYS) {
          const legacy = localStorage.getItem(key);
          if (legacy) {
            let arr;
            try {
              const parsed = JSON.parse(legacy);
              arr = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.tasks) ? parsed.tasks : []);
            } catch {
              arr = [];
            }
            tasks = Array.isArray(arr) ? arr : [];
            normalizeOrders(true);
            save(); // guarda ya en v3
            return;
          }
        }
        tasks = [];
      } catch {
        tasks = [];
      }
    }

    function normalizeOrders(isMigrating = false) {
      // Asegura orderPending / orderCompleted coherentes
      const pend = tasks.filter(t => !t.completed);
      const comp = tasks.filter(t => t.completed);
      if (isMigrating || pend.some(t => typeof t.orderPending !== 'number')) {
        pend.sort((a,b) => (b.createdAt||0) - (a.createdAt||0));
        pend.forEach((t, i) => t.orderPending = i);
      }
      if (isMigrating || comp.some(t => typeof t.orderCompleted !== 'number')) {
        comp.sort((a,b) => (b.completedAt||b.createdAt||0) - (a.completedAt||a.createdAt||0));
        comp.forEach((t, i) => t.orderCompleted = i);
      }
    }

    function save() {
      const payload = getSnapshot();
      localStorage.setItem(DB_KEY, JSON.stringify(payload));
    }

    function render() {
      // limpiar
      pendingList.innerHTML = '';
      completedList.innerHTML = '';

      // ordenar por orden manual; fallback timestamps si no existen
      const pend = tasks
        .filter(t => !t.completed)
        .sort((a,b) => (a.orderPending ?? a.createdAt) - (b.orderPending ?? b.createdAt));
      const comp = tasks
        .filter(t => t.completed)
        .sort((a,b) => (a.orderCompleted ?? a.completedAt ?? a.createdAt) - (b.orderCompleted ?? b.completedAt ?? b.createdAt));

      pend.forEach(t => pendingList.appendChild(renderItem(t, false)));
      comp.forEach(t => completedList.appendChild(renderItem(t, true)));

      pendingEmpty.classList.toggle('d-none', pend.length !== 0);
      completedEmpty.classList.toggle('d-none', comp.length !== 0);

      // activar DnD en ambas listas
      enableListDnD(pendingList, false);
      enableListDnD(completedList, true);
    }

    function renderItem(task, isCompletedList) {
      const li = document.createElement('li');
      li.className = 'list-group-item fade-enter';
      li.dataset.id = task.id;
      li.setAttribute('draggable', 'true'); // activar drag en el item

      const row = document.createElement('div');
      row.className = 'd-flex align-items-center gap-2';

      // Asidero de arrastre
      const dragBtn = document.createElement('button');
      dragBtn.className = 'btn btn-outline-secondary btn-sm btn-icon drag-handle';
      dragBtn.setAttribute('title', 'Arrastrar para reordenar');
      dragBtn.innerHTML = '<i class="bi bi-grip-vertical"></i>';

      // Checkbox
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'form-check-input task-checkbox mt-0';
      cb.checked = !!task.completed;
      cb.setAttribute('aria-label', task.completed ? 'Desmarcar tarea' : 'Marcar tarea');
      cb.addEventListener('change', () => toggleCompleted(task.id, cb.checked));

      // Texto
      const text = document.createElement('span');
      text.className = 'task-text';
      text.textContent = task.text; // evita HTML injection
      if (task.completed) text.classList.add('completed');

      // Acciones
      const actions = document.createElement('div');
      actions.className = 'ms-auto d-flex gap-1';

      if (!task.completed) {
        const editBtn = document.createElement('button');
        editBtn.className = 'btn btn-outline-secondary btn-sm btn-icon';
        editBtn.setAttribute('title', 'Editar');
        editBtn.innerHTML = '<i class="bi bi-pencil"></i>';
        editBtn.addEventListener('click', () => openEdit(task.id));
        actions.appendChild(editBtn);
      }

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-outline-danger btn-sm btn-icon';
      delBtn.setAttribute('title', 'Eliminar');
      delBtn.innerHTML = '<i class="bi bi-trash"></i>';
      delBtn.addEventListener('click', () => removeTask(task.id));

      actions.appendChild(delBtn);

      row.appendChild(dragBtn);
      row.appendChild(cb);
      row.appendChild(text);
      row.appendChild(actions);
      li.appendChild(row);

      // Eventos drag para el propio item (delegados también a la lista)
      li.addEventListener('dragstart', (e) => {
        li.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', task.id);
      });
      li.addEventListener('dragend', () => {
        li.classList.remove('dragging');
        clearDropIndicators();
      });

      return li;
    }

    // Acciones
    function addTask(txt) {
      const text = txt.trim();
      if (!text) return;
      const nextOrder = getNextOrderIndex(false); // al final de pendientes
      const t = { id: uid(), text, completed: false, createdAt: Date.now(), orderPending: nextOrder };
      tasks.push(t);
      save();
      render();
    }

    function addTasksBulk(texts) {
      const now = Date.now();
      const base = getNextOrderIndex(false);
      let count = 0;
      texts.forEach((txt, idx) => {
        const t = (txt || '').trim();
        if (!t) return;
        tasks.push({
          id: uid(),
          text: t,
          completed: false,
          createdAt: now + idx,
          orderPending: base + count
        });
        count++;
      });
      if (count === 0) return 0;
      save();
      render();
      return count;
    }

    function importFromTxtContent(content) {
      const lines = (content || '').split(/\r?\n/);
      const texts = [];
      for (const raw of lines) {
        const line = (raw || '').trim();
        if (!line) continue;
        const bullet = line.replace(/^[*-]\s*/, '');
        const m = bullet.match(/^(.*?)\s*->\s*(.+)$/);
        let text;
        if (m) {
          const code = m[1].trim();
          const desc = m[2].trim();
          text = (code ? '[' + code + '] ' : '') + desc;
        } else {
          text = bullet; // línea sin "->"
        }
        texts.push(text);
      }
      return addTasksBulk(texts);
    }

    function importFromJsonContent(content, opts) {
      const options = Object.assign({ replace: true }, opts || {});
      let data;
      try { data = JSON.parse(content); } catch (e) { throw new Error('JSON inválido'); }
      let arr = Array.isArray(data) ? data : (data && Array.isArray(data.tasks) ? data.tasks : null);
      if (!arr) throw new Error('Formato no válido: usa un array de tareas o { "tasks": [...] }');
      const now = Date.now();
      const normalized = arr.map((t, idx) => {
        const text = (t && (t.text ?? t.title ?? '')).toString().trim();
        if (!text) return null;
        const completed = !!t.completed;
        return {
          id: (t && typeof t.id === 'string' && t.id) ? t.id : uid(),
          text,
          completed,
          createdAt: (t && typeof t.createdAt === 'number') ? t.createdAt : (now + idx),
          completedAt: completed ? ((t && typeof t.completedAt === 'number') ? t.completedAt : now + idx) : undefined,
          orderPending: typeof t.orderPending === 'number' ? t.orderPending : undefined,
          orderCompleted: typeof t.orderCompleted === 'number' ? t.orderCompleted : undefined
        };
      }).filter(Boolean);
      if (normalized.length === 0) return 0;
      tasks = options.replace ? normalized : [...normalized, ...tasks];
      normalizeOrders();
      save();
      render();
      return normalized.length;
    }

    function toggleCompleted(id, completed) {
      const t = tasks.find(x => x.id === id);
      if (!t) return;
      t.completed = !!completed;
      t.completedAt = completed ? Date.now() : undefined;
      if (completed) {
        // pasa a completadas -> colócalo al final (o al principio si prefieres)
        t.orderCompleted = getNextOrderIndex(true);
      } else {
        // regresa a pendientes -> colócalo al final
        t.orderPending = getNextOrderIndex(false);
      }
      save();
      render();
    }

    function removeTask(id) {
      const t = tasks.find(x => x.id === id);
      if (!t) return;
      if (!confirm('¿Eliminar la tarea?')) return;
      tasks = tasks.filter(x => x.id !== id);
      save();
      render();
    }

    function openEdit(id) {
      const t = tasks.find(x => x.id === id);
      if (!t || t.completed) return; // solo en pendientes
      editId = id;
      editInput.value = t.text;
      setTimeout(() => { editInput.focus(); editInput.select(); }, 75);
      editModal.show();
    }

    function applyEdit() {
      const t = tasks.find(x => x.id === editId);
      if (!t) return;
      const val = editInput.value.trim();
      if (!val) return; // evita vacío
      t.text = val;
      save();
      render();
      editModal.hide();
      editId = null;
    }

    // ---- Drag & Drop helpers ----
    function enableListDnD(listEl, isCompletedList) {
      // listeners de la lista
      listEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        const afterEl = getDragAfterElement(listEl, e.clientY);
        showDropIndicator(listEl, afterEl);
      });

      listEl.addEventListener('dragleave', () => {
        listEl.classList.remove('drag-hover');
        clearDropIndicators();
      });

      listEl.addEventListener('drop', (e) => {
        e.preventDefault();
        const draggedId = e.dataTransfer.getData('text/plain');
        const dragged = listEl.querySelector('[data-id="'+draggedId+'"]') || document.querySelector('[data-id="'+draggedId+'"]');

        // Solo permitimos reordenar dentro de la misma lista (no cambiar estado por arrastre)
        if (!dragged || dragged.parentElement !== listEl) {
          clearDropIndicators();
          return;
        }

        const afterEl = getDragAfterElement(listEl, e.clientY);
        if (afterEl == null) {
          listEl.appendChild(dragged);
        } else {
          listEl.insertBefore(dragged, afterEl);
        }

        listEl.classList.remove('drag-hover');
        clearDropIndicators();
        persistListOrder(listEl, isCompletedList);
      });

      // resaltado al entrar con item válido
      listEl.addEventListener('dragenter', (e) => {
        e.preventDefault();
        listEl.classList.add('drag-hover');
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('li.list-group-item:not(.dragging)')];
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function showDropIndicator(listEl, afterEl) {
      clearDropIndicators();
      const indicator = document.createElement('div');
      indicator.className = 'drop-indicator';
      if (!afterEl) {
        listEl.appendChild(indicator);
      } else {
        listEl.insertBefore(indicator, afterEl);
      }
    }

    function clearDropIndicators() {
      document.querySelectorAll('.drop-indicator').forEach(d => d.remove());
    }

    function persistListOrder(listEl, isCompletedList) {
      const ids = [...listEl.querySelectorAll('li.list-group-item')].map(li => li.dataset.id);
      ids.forEach((id, idx) => {
        const t = tasks.find(x => x.id === id);
        if (!t) return;
        if (isCompletedList) t.orderCompleted = idx;
        else t.orderPending = idx;
      });
      save();
      // No re-render inmediato para evitar "salto"; el DOM ya refleja el nuevo orden
    }

    function getNextOrderIndex(isCompletedList) {
      const arr = tasks.filter(t => !!t.completed === !!isCompletedList);
      if (arr.length === 0) return 0;
      const key = isCompletedList ? 'orderCompleted' : 'orderPending';
      const max = arr.reduce((m,t) => Math.max(m, typeof t[key] === 'number' ? t[key] : -1), -1);
      return max + 1;
    }

    // Eventos
    addForm.addEventListener('submit', (e) => {
      e.preventDefault();
      addTask(newTaskInput.value);
      newTaskInput.value = '';
      newTaskInput.focus();
    });

    editForm.addEventListener('submit', (e) => {
      e.preventDefault();
      applyEdit();
    });

    // Importar/Exportar
    importTxtBtn.addEventListener('click', () => txtFileInput.click());
    txtFileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const count = importFromTxtContent(text);
        alert('Importadas ' + count + ' tareas desde TXT.');
      } catch (err) {
        alert('No se pudo importar el archivo TXT.');
        console.error(err);
      } finally {
        e.target.value = '';
      }
    });

    exportJsonBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(getSnapshot(), null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'tareas.json';
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
    });

    // Cargar y pintar
    load();
    render();
  })();
  </script>
</body>
</html>
